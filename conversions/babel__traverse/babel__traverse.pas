unit Babel__traverse;

interface

(*
   * Auto-generated from TypeScript definitions
   * Source: babel__traverse
   * Generator: ts2pas v1.0.0-alpha.1
   *)


  function explode(visitor: Visitor<S>): Variant;

  procedure verify(visitor: Visitor);

  function merge(visitors: array of Visitor<State>): Visitor<State>;

  function merge(visitors: array of Visitor; states?: array of Variant; wrapper?: function: VisitNodeFunction<Variant, Node>): Visitor;

  procedure clear;

  procedure clearPath;

  procedure clearScope;

  TraverseOptions = Variant;

  Scope = class external
    procedure Create(path: NodePath; parentScope?: Scope);
    property uid: Float;
    property path: NodePath;
    property block: Node;
    property labels: Variant;
    property parentBlock: Node;
    property parent: Scope;
    property hub: HubInterface;
    property bindings: Variant;
    property references: Variant;
    property globals: Variant;
    property uids: Variant;
    property data: Variant;
    property crawling: Boolean;
    property globals: array of String;
    property contextVariables: array of String;
    procedure traverse(node: Variant; opts: TraverseOptions<S>; state: S);
    procedure traverse(node: Variant; opts?: TraverseOptions; state?: Variant);
    function generateDeclaredUidIdentifier(name?: String): t.Identifier;
    function generateUidIdentifier(name?: String): t.Identifier;
    function generateUid(name?: String): String;
    function generateUidIdentifierBasedOnNode(parent: Node; defaultName?: String): t.Identifier;
    function isStatic(node: Node): Boolean;
    function maybeGenerateMemoised(node: Node; dontPush?: Boolean): t.Identifier;
    procedure checkBlockScopedCollisions(local: Binding; kind: BindingKind; name: String; id: Variant);
    procedure rename(oldName: String; newName?: String; block?: Node);
    procedure dump;
    function toArray(node: t.Node; i?: Variant; arrayLikeIsIterable?: Boolean): Variant;
    function hasLabel(name: String): Boolean;
    function getLabel(name: String): NodePath<t.LabeledStatement>;
    procedure registerLabel(path: NodePath<t.LabeledStatement>);
    procedure registerDeclaration(path: NodePath);
    function buildUndefinedNode: t.UnaryExpression;
    procedure registerConstantViolation(path: NodePath);
    procedure registerBinding(kind: BindingKind; path: NodePath; bindingPath?: NodePath);
    procedure addGlobal(node: Variant);
    function hasUid(name: String): Boolean;
    function hasGlobal(name: String): Boolean;
    function hasReference(name: String): Boolean;
    function isPure(node: Node; constantsOnly?: Boolean): Boolean;
    function setData(key: String; val: Variant): Variant;
    function getData(key: String): Variant;
    procedure removeData(key: String);
    procedure crawl;
    procedure push(opts: Variant);
    function getProgramParent: Scope;
    function getFunctionParent: Scope;
    function getBlockParent: Scope;
    function getPatternParent: Scope;
    function getAllBindings: Variant;
    function getAllBindingsOfKind(kinds: array of String): Variant;
    function bindingIdentifierEquals(name: String; node: Node): Boolean;
    function getBinding(name: String): Binding;
    function getOwnBinding(name: String): Binding;
    function getBindingIdentifier(name: String): t.Identifier;
    function getOwnBindingIdentifier(name: String): t.Identifier;
    function hasOwnBinding(name: String): Boolean;
    function hasBinding(name: String; optsOrNoGlobals?: Boolean): Boolean;
    function parentHasBinding(name: String; opts?: Variant): Boolean;
    procedure moveBindingTo(name: String; scope: Scope);
    procedure removeOwnBinding(name: String);
    procedure removeBinding(name: String);
  end;

  BindingKind = String;

  Binding = class external
    procedure Create(opts: Variant);
    property identifier: t.Identifier;
    property scope: Scope;
    property path: NodePath;
    property kind: BindingKind;
    property referenced: Boolean;
    property references: Float;
    property referencePaths: array of NodePath;
    property constant: Boolean;
    property constantViolations: array of NodePath;
    property hasDeoptedValue: Boolean;
    property hasValue: Boolean;
    property value: Variant;
    procedure deopValue;
    procedure setValue(value: Variant);
    procedure clearValue;
    procedure reassign(path: NodePath);
    procedure reference(path: NodePath);
    procedure dereference;
  end;

  Visitor = Variant;

  VisitNode = Variant;

  VisitNodeFunction = procedure;

  NodeType = Variant;

  VisitNodeObject = interface
    property enter: VisitNodeFunction<S, P>;
    property exit: VisitNodeFunction<S, P>;
  end;

  NodeKeyOfArrays = Variant;

  NodeKeyOfNodes = Variant;

  NodePaths = Variant;

  NodeListType = Variant;

  NodesInsertionParam = Variant;

  NodePath = class external
    procedure Create(hub: HubInterface; parent: Node);
    property parent: Node;
    property hub: Hub;
    property data: Variant;
    property context: TraversalContext;
    property scope: Scope;
    property contexts: array of TraversalContext;
    property state: Variant;
    property opts: Variant;
    property skipKeys: Variant;
    property parentPath: Variant;
    property container: Variant;
    property listKey: String;
    property key: Variant;
    property node: T;
    property type: Variant;
    property shouldSkip: Boolean;
    property shouldStop: Boolean;
    property removed: Boolean;
    property inList: Boolean;
    property parentKey: String;
    property typeAnnotation: Variant;
    function get(opts: Variant): NodePath<Variant>; static
    function get(opts: Variant): Variant; static
    function getScope(scope: Scope): Scope;
    function setData(key: String; val: Variant): Variant;
    function getData(key: String; def?: Variant): Variant;
    function hasNode: Variant;
    function buildCodeFrameError(msg: String; Error?: ErrorConstructor): Error;
    procedure traverse(visitor: TraverseOptions<T>; state: T);
    procedure traverse(visitor: TraverseOptions);
    procedure set(key: String; node: Variant);
    function getPathLocation: String;
    procedure debug(buildMessage: function: String);
    function findParent(callback: function: Boolean): NodePath;
    function find(callback: function: Boolean): NodePath;
    function getFunctionParent: NodePath<t.Function>;
    function getStatementParent: NodePath<t.Statement>;
    function getEarliestCommonAncestorFrom(paths: array of NodePath): NodePath;
    function getDeepestCommonAncestorFrom(paths: array of NodePath; filter?: function: NodePath): NodePath;
    function getAncestry: array of Variant;
    function isAncestor(maybeDescendant: NodePath): Boolean;
    function isDescendant(maybeAncestor: NodePath): Boolean;
    function inType(candidateTypes: array of String): Boolean;
    function getTypeAnnotation: Variant;
    function isBaseType(baseName: String; soft?: Boolean): Boolean;
    function couldBeBaseType(name: String): Boolean;
    function baseTypeStrictlyMatches(rightArg: NodePath): Boolean;
    function isGenericType(genericName: String): Boolean;
    function replaceWithMultiple(nodes: Nodes): NodePaths<Nodes>;
    function replaceWithSourceString(replacement: String): array of NodePath;
    function replaceWith(replacementPath: Variant): array of NodePath<R>;
    function replaceWith(replacementPath: R): array of R;
    function replaceExpressionWithStatements(nodes: array of t.Statement): NodePaths<Variant>;
    function replaceInline(nodes: Nodes): NodePaths<Nodes>;
    function evaluateTruthy: Boolean;
    function evaluate: Variant;
    function matchesPattern(pattern: String; allowPartial?: Boolean): Boolean;
    function has(key: String): Boolean;
    function isStatic: Boolean;
    function is(key: String): Boolean;
    function isnt(key: String): Boolean;
    function equals(key: String; value: Variant): Boolean;
    function isNodeType(type: String): Boolean;
    function canHaveVariableDeclarationOrExpression: Boolean;
    function canSwapBetweenExpressionAndStatement(replacement: Node): Boolean;
    function isCompletionRecord(allowInsideFunction?: Boolean): Boolean;
    function isStatementOrBlock: Boolean;
    function referencesImport(moduleSource: String; importName: String): Boolean;
    function getSource: String;
    function willIMaybeExecuteBefore(target: NodePath): Boolean;
    function resolve(dangerous?: Boolean; resolved?: array of NodePath): NodePath;
    function isConstantExpression: Boolean;
    function isInStrictMode: Boolean;
    function call(key: String): Boolean;
    function isDenylisted: Boolean;
    function isBlacklisted: Boolean;
    function visit: Boolean;
    procedure skip;
    procedure skipKey(key: String);
    procedure stop;
    procedure setScope;
    function setContext(context?: TraversalContext): Variant;
    procedure resync;
    procedure popContext;
    procedure pushContext(context: TraversalContext);
    procedure requeue(pathToQueue?: NodePath);
    procedure remove;
    function toComputedKey: Variant;
    procedure arrowFunctionToShadowed;
    procedure unwrapFunctionEnvironment;
    function arrowFunctionToExpression: NodePath<Variant>;
    function ensureBlock(this: NodePath<Variant>): Variant;
    function insertBefore(nodes: Nodes): NodePaths<Nodes>;
    function insertAfter(nodes: Nodes): NodePaths<Nodes>;
    procedure updateSiblingKeys(fromIndex: Float; incrementBy: Float);
    function unshiftContainer(this: NodePath<T>; listKey: K; nodes: Nodes): NodePaths<Nodes>;
    function pushContainer(this: NodePath<T>; listKey: K; nodes: Nodes): NodePaths<Nodes>;
    procedure hoist(scope: Scope);
    function getOpposite: NodePath;
    function getCompletionRecords: array of NodePath;
    function getSibling(key: Variant): NodePath;
    function getPrevSibling: NodePath;
    function getNextSibling: NodePath;
    function getAllPrevSiblings: array of NodePath;
    function getAllNextSiblings: array of NodePath;
    function get(key: K; context?: Variant): NodePathResult<Variant>;
    function get(path: P; context?: Variant): NodePathResult<ImplGetRecursive<T, P>>;
    function get(key: String; context?: Variant): Variant;
    function getBindingIdentifiers(duplicates: Boolean): Variant;
    function getOuterBindingIdentifiers(duplicates: Boolean): Variant;
    function getBindingIdentifierPaths(duplicates: Boolean; outerOnly?: Boolean): Variant;
    function getOuterBindingIdentifierPaths(duplicates: Boolean): Variant;
    function getOuterBindingIdentifierPaths(duplicates?: Boolean; outerOnly?: Boolean): Variant;
    procedure shareCommentsWithSiblings;
    procedure addComment(type: t.CommentTypeShorthand; content: String; line?: Boolean);
    procedure addComments(type: t.CommentTypeShorthand; comments: array of t.Comment);
    function isAccessor(opts?: Variant): Variant;
    function isAnyTypeAnnotation(opts?: Variant): Variant;
    function isArgumentPlaceholder(opts?: Variant): Variant;
    function isArrayExpression(opts?: Variant): Variant;
    function isArrayPattern(opts?: Variant): Variant;
    function isArrayTypeAnnotation(opts?: Variant): Variant;
    function isArrowFunctionExpression(opts?: Variant): Variant;
    function isAssignmentExpression(opts?: Variant): Variant;
    function isAssignmentPattern(opts?: Variant): Variant;
    function isAwaitExpression(opts?: Variant): Variant;
    function isBigIntLiteral(opts?: Variant): Variant;
    function isBinary(opts?: Variant): Variant;
    function isBinaryExpression(opts?: Variant): Variant;
    function isBindExpression(opts?: Variant): Variant;
    function isBlock(opts?: Variant): Variant;
    function isBlockParent(opts?: Variant): Variant;
    function isBlockStatement(opts?: Variant): Variant;
    function isBooleanLiteral(opts?: Variant): Variant;
    function isBooleanLiteralTypeAnnotation(opts?: Variant): Variant;
    function isBooleanTypeAnnotation(opts?: Variant): Variant;
    function isBreakStatement(opts?: Variant): Variant;
    function isCallExpression(opts?: Variant): Variant;
    function isCatchClause(opts?: Variant): Variant;
    function isClass(opts?: Variant): Variant;
    function isClassAccessorProperty(opts?: Variant): Variant;
    function isClassBody(opts?: Variant): Variant;
    function isClassDeclaration(opts?: Variant): Variant;
    function isClassExpression(opts?: Variant): Variant;
    function isClassImplements(opts?: Variant): Variant;
    function isClassMethod(opts?: Variant): Variant;
    function isClassPrivateMethod(opts?: Variant): Variant;
    function isClassPrivateProperty(opts?: Variant): Variant;
    function isClassProperty(opts?: Variant): Variant;
    function isCompletionStatement(opts?: Variant): Variant;
    function isConditional(opts?: Variant): Variant;
    function isConditionalExpression(opts?: Variant): Variant;
    function isContinueStatement(opts?: Variant): Variant;
    function isDebuggerStatement(opts?: Variant): Variant;
    function isDecimalLiteral(opts?: Variant): Variant;
    function isDeclaration(opts?: Variant): Variant;
    function isDeclareClass(opts?: Variant): Variant;
    function isDeclareExportAllDeclaration(opts?: Variant): Variant;
    function isDeclareExportDeclaration(opts?: Variant): Variant;
    function isDeclareFunction(opts?: Variant): Variant;
    function isDeclareInterface(opts?: Variant): Variant;
    function isDeclareModule(opts?: Variant): Variant;
    function isDeclareModuleExports(opts?: Variant): Variant;
    function isDeclareOpaqueType(opts?: Variant): Variant;
    function isDeclareTypeAlias(opts?: Variant): Variant;
    function isDeclareVariable(opts?: Variant): Variant;
    function isDeclaredPredicate(opts?: Variant): Variant;
    function isDecorator(opts?: Variant): Variant;
    function isDirective(opts?: Variant): Variant;
    function isDirectiveLiteral(opts?: Variant): Variant;
    function isDoExpression(opts?: Variant): Variant;
    function isDoWhileStatement(opts?: Variant): Variant;
    function isEmptyStatement(opts?: Variant): Variant;
    function isEmptyTypeAnnotation(opts?: Variant): Variant;
    function isEnumBody(opts?: Variant): Variant;
    function isEnumBooleanBody(opts?: Variant): Variant;
    function isEnumBooleanMember(opts?: Variant): Variant;
    function isEnumDeclaration(opts?: Variant): Variant;
    function isEnumDefaultedMember(opts?: Variant): Variant;
    function isEnumMember(opts?: Variant): Variant;
    function isEnumNumberBody(opts?: Variant): Variant;
    function isEnumNumberMember(opts?: Variant): Variant;
    function isEnumStringBody(opts?: Variant): Variant;
    function isEnumStringMember(opts?: Variant): Variant;
    function isEnumSymbolBody(opts?: Variant): Variant;
    function isExistsTypeAnnotation(opts?: Variant): Variant;
    function isExportAllDeclaration(opts?: Variant): Variant;
    function isExportDeclaration(opts?: Variant): Variant;
    function isExportDefaultDeclaration(opts?: Variant): Variant;
    function isExportDefaultSpecifier(opts?: Variant): Variant;
    function isExportNamedDeclaration(opts?: Variant): Variant;
    function isExportNamespaceSpecifier(opts?: Variant): Variant;
    function isExportSpecifier(opts?: Variant): Variant;
    function isExpression(opts?: Variant): Variant;
    function isExpressionStatement(opts?: Variant): Variant;
    function isExpressionWrapper(opts?: Variant): Variant;
    function isFile(opts?: Variant): Variant;
    function isFlow(opts?: Variant): Variant;
    function isFlowBaseAnnotation(opts?: Variant): Variant;
    function isFlowDeclaration(opts?: Variant): Variant;
    function isFlowPredicate(opts?: Variant): Variant;
    function isFlowType(opts?: Variant): Variant;
    function isFor(opts?: Variant): Variant;
    function isForInStatement(opts?: Variant): Variant;
    function isForOfStatement(opts?: Variant): Variant;
    function isForStatement(opts?: Variant): Variant;
    function isForXStatement(opts?: Variant): Variant;
    function isFunction(opts?: Variant): Variant;
    function isFunctionDeclaration(opts?: Variant): Variant;
    function isFunctionExpression(opts?: Variant): Variant;
    function isFunctionParameter(opts?: Variant): Variant;
    function isFunctionParent(opts?: Variant): Variant;
    function isFunctionTypeAnnotation(opts?: Variant): Variant;
    function isFunctionTypeParam(opts?: Variant): Variant;
    function isGenericTypeAnnotation(opts?: Variant): Variant;
    function isIdentifier(opts?: Variant): Variant;
    function isIfStatement(opts?: Variant): Variant;
    function isImmutable(opts?: Variant): Variant;
    function isImport(opts?: Variant): Variant;
    function isImportAttribute(opts?: Variant): Variant;
    function isImportDeclaration(opts?: Variant): Variant;
    function isImportExpression(opts?: Variant): Variant;
    function isImportDefaultSpecifier(opts?: Variant): Variant;
    function isImportNamespaceSpecifier(opts?: Variant): Variant;
    function isImportOrExportDeclaration(opts?: Variant): Variant;
    function isImportSpecifier(opts?: Variant): Variant;
    function isIndexedAccessType(opts?: Variant): Variant;
    function isInferredPredicate(opts?: Variant): Variant;
    function isInterfaceDeclaration(opts?: Variant): Variant;
    function isInterfaceExtends(opts?: Variant): Variant;
    function isInterfaceTypeAnnotation(opts?: Variant): Variant;
    function isInterpreterDirective(opts?: Variant): Variant;
    function isIntersectionTypeAnnotation(opts?: Variant): Variant;
    function isJSX(opts?: Variant): Variant;
    function isJSXAttribute(opts?: Variant): Variant;
    function isJSXClosingElement(opts?: Variant): Variant;
    function isJSXClosingFragment(opts?: Variant): Variant;
    function isJSXElement(opts?: Variant): Variant;
    function isJSXEmptyExpression(opts?: Variant): Variant;
    function isJSXExpressionContainer(opts?: Variant): Variant;
    function isJSXFragment(opts?: Variant): Variant;
    function isJSXIdentifier(opts?: Variant): Variant;
    function isJSXMemberExpression(opts?: Variant): Variant;
    function isJSXNamespacedName(opts?: Variant): Variant;
    function isJSXOpeningElement(opts?: Variant): Variant;
    function isJSXOpeningFragment(opts?: Variant): Variant;
    function isJSXSpreadAttribute(opts?: Variant): Variant;
    function isJSXSpreadChild(opts?: Variant): Variant;
    function isJSXText(opts?: Variant): Variant;
    function isLVal(opts?: Variant): Variant;
    function isLabeledStatement(opts?: Variant): Variant;
    function isLiteral(opts?: Variant): Variant;
    function isLogicalExpression(opts?: Variant): Variant;
    function isLoop(opts?: Variant): Variant;
    function isMemberExpression(opts?: Variant): Variant;
    function isMetaProperty(opts?: Variant): Variant;
    function isMethod(opts?: Variant): Variant;
    function isMiscellaneous(opts?: Variant): Variant;
    function isMixedTypeAnnotation(opts?: Variant): Variant;
    function isModuleDeclaration(opts?: Variant): Variant;
    function isModuleExpression(opts?: Variant): Variant;
    function isModuleSpecifier(opts?: Variant): Variant;
    function isNewExpression(opts?: Variant): Variant;
    function isNoop(opts?: Variant): Variant;
    function isNullLiteral(opts?: Variant): Variant;
    function isNullLiteralTypeAnnotation(opts?: Variant): Variant;
    function isNullableTypeAnnotation(opts?: Variant): Variant;
    function isNumberLiteral(opts?: Variant): Variant;
    function isNumberLiteralTypeAnnotation(opts?: Variant): Variant;
    function isNumberTypeAnnotation(opts?: Variant): Variant;
    function isNumericLiteral(opts?: Variant): Variant;
    function isObjectExpression(opts?: Variant): Variant;
    function isObjectMember(opts?: Variant): Variant;
    function isObjectMethod(opts?: Variant): Variant;
    function isObjectPattern(opts?: Variant): Variant;
    function isObjectProperty(opts?: Variant): Variant;
    function isObjectTypeAnnotation(opts?: Variant): Variant;
    function isObjectTypeCallProperty(opts?: Variant): Variant;
    function isObjectTypeIndexer(opts?: Variant): Variant;
    function isObjectTypeInternalSlot(opts?: Variant): Variant;
    function isObjectTypeProperty(opts?: Variant): Variant;
    function isObjectTypeSpreadProperty(opts?: Variant): Variant;
    function isOpaqueType(opts?: Variant): Variant;
    function isOptionalCallExpression(opts?: Variant): Variant;
    function isOptionalIndexedAccessType(opts?: Variant): Variant;
    function isOptionalMemberExpression(opts?: Variant): Variant;
    function isParenthesizedExpression(opts?: Variant): Variant;
    function isPattern(opts?: Variant): Variant;
    function isPatternLike(opts?: Variant): Variant;
    function isPipelineBareFunction(opts?: Variant): Variant;
    function isPipelinePrimaryTopicReference(opts?: Variant): Variant;
    function isPipelineTopicExpression(opts?: Variant): Variant;
    function isPlaceholder(opts?: Variant): Variant;
    function isPrivate(opts?: Variant): Variant;
    function isPrivateName(opts?: Variant): Variant;
    function isProgram(opts?: Variant): Variant;
    function isProperty(opts?: Variant): Variant;
    function isPureish(opts?: Variant): Variant;
    function isQualifiedTypeIdentifier(opts?: Variant): Variant;
    function isRecordExpression(opts?: Variant): Variant;
    function isRegExpLiteral(opts?: Variant): Variant;
    function isRegexLiteral(opts?: Variant): Variant;
    function isRestElement(opts?: Variant): Variant;
    function isRestProperty(opts?: Variant): Variant;
    function isReturnStatement(opts?: Variant): Variant;
    function isScopable(opts?: Variant): Variant;
    function isSequenceExpression(opts?: Variant): Variant;
    function isSpreadElement(opts?: Variant): Variant;
    function isSpreadProperty(opts?: Variant): Variant;
    function isStandardized(opts?: Variant): Variant;
    function isStatement(opts?: Variant): Variant;
    function isStaticBlock(opts?: Variant): Variant;
    function isStringLiteral(opts?: Variant): Variant;
    function isStringLiteralTypeAnnotation(opts?: Variant): Variant;
    function isStringTypeAnnotation(opts?: Variant): Variant;
    function isSuper(opts?: Variant): Variant;
    function isSwitchCase(opts?: Variant): Variant;
    function isSwitchStatement(opts?: Variant): Variant;
    function isSymbolTypeAnnotation(opts?: Variant): Variant;
    function isTSAnyKeyword(opts?: Variant): Variant;
    function isTSArrayType(opts?: Variant): Variant;
    function isTSAsExpression(opts?: Variant): Variant;
    function isTSBaseType(opts?: Variant): Variant;
    function isTSBigIntKeyword(opts?: Variant): Variant;
    function isTSBooleanKeyword(opts?: Variant): Variant;
    function isTSCallSignatureDeclaration(opts?: Variant): Variant;
    function isTSConditionalType(opts?: Variant): Variant;
    function isTSConstructSignatureDeclaration(opts?: Variant): Variant;
    function isTSConstructorType(opts?: Variant): Variant;
    function isTSDeclareFunction(opts?: Variant): Variant;
    function isTSDeclareMethod(opts?: Variant): Variant;
    function isTSEntityName(opts?: Variant): Variant;
    function isTSEnumBody(opts?: Variant): Variant;
    function isTSEnumDeclaration(opts?: Variant): Variant;
    function isTSEnumMember(opts?: Variant): Variant;
    function isTSExportAssignment(opts?: Variant): Variant;
    function isTSExpressionWithTypeArguments(opts?: Variant): Variant;
    function isTSExternalModuleReference(opts?: Variant): Variant;
    function isTSFunctionType(opts?: Variant): Variant;
    function isTSImportEqualsDeclaration(opts?: Variant): Variant;
    function isTSImportType(opts?: Variant): Variant;
    function isTSIndexSignature(opts?: Variant): Variant;
    function isTSIndexedAccessType(opts?: Variant): Variant;
    function isTSInferType(opts?: Variant): Variant;
    function isTSInstantiationExpression(opts?: Variant): Variant;
    function isTSInterfaceBody(opts?: Variant): Variant;
    function isTSInterfaceDeclaration(opts?: Variant): Variant;
    function isTSIntersectionType(opts?: Variant): Variant;
    function isTSIntrinsicKeyword(opts?: Variant): Variant;
    function isTSLiteralType(opts?: Variant): Variant;
    function isTSMappedType(opts?: Variant): Variant;
    function isTSMethodSignature(opts?: Variant): Variant;
    function isTSModuleBlock(opts?: Variant): Variant;
    function isTSModuleDeclaration(opts?: Variant): Variant;
    function isTSNamedTupleMember(opts?: Variant): Variant;
    function isTSNamespaceExportDeclaration(opts?: Variant): Variant;
    function isTSNeverKeyword(opts?: Variant): Variant;
    function isTSNonNullExpression(opts?: Variant): Variant;
    function isTSNullKeyword(opts?: Variant): Variant;
    function isTSNumberKeyword(opts?: Variant): Variant;
    function isTSObjectKeyword(opts?: Variant): Variant;
    function isTSOptionalType(opts?: Variant): Variant;
    function isTSParameterProperty(opts?: Variant): Variant;
    function isTSParenthesizedType(opts?: Variant): Variant;
    function isTSPropertySignature(opts?: Variant): Variant;
    function isTSQualifiedName(opts?: Variant): Variant;
    function isTSRestType(opts?: Variant): Variant;
    function isTSSatisfiesExpression(opts?: Variant): Variant;
    function isTSStringKeyword(opts?: Variant): Variant;
    function isTSSymbolKeyword(opts?: Variant): Variant;
    function isTSTemplateLiteralType(opts?: Variant): Variant;
    function isTSThisType(opts?: Variant): Variant;
    function isTSTupleType(opts?: Variant): Variant;
    function isTSType(opts?: Variant): Variant;
    function isTSTypeAliasDeclaration(opts?: Variant): Variant;
    function isTSTypeAnnotation(opts?: Variant): Variant;
    function isTSTypeAssertion(opts?: Variant): Variant;
    function isTSTypeElement(opts?: Variant): Variant;
    function isTSTypeLiteral(opts?: Variant): Variant;
    function isTSTypeOperator(opts?: Variant): Variant;
    function isTSTypeParameter(opts?: Variant): Variant;
    function isTSTypeParameterDeclaration(opts?: Variant): Variant;
    function isTSTypeParameterInstantiation(opts?: Variant): Variant;
    function isTSTypePredicate(opts?: Variant): Variant;
    function isTSTypeQuery(opts?: Variant): Variant;
    function isTSTypeReference(opts?: Variant): Variant;
    function isTSUndefinedKeyword(opts?: Variant): Variant;
    function isTSUnionType(opts?: Variant): Variant;
    function isTSUnknownKeyword(opts?: Variant): Variant;
    function isTSVoidKeyword(opts?: Variant): Variant;
    function isTaggedTemplateExpression(opts?: Variant): Variant;
    function isTemplateElement(opts?: Variant): Variant;
    function isTemplateLiteral(opts?: Variant): Variant;
    function isTerminatorless(opts?: Variant): Variant;
    function isThisExpression(opts?: Variant): Variant;
    function isThisTypeAnnotation(opts?: Variant): Variant;
    function isThrowStatement(opts?: Variant): Variant;
    function isTopicReference(opts?: Variant): Variant;
    function isTryStatement(opts?: Variant): Variant;
    function isTupleExpression(opts?: Variant): Variant;
    function isTupleTypeAnnotation(opts?: Variant): Variant;
    function isTypeAlias(opts?: Variant): Variant;
    function isTypeAnnotation(opts?: Variant): Variant;
    function isTypeCastExpression(opts?: Variant): Variant;
    function isTypeParameter(opts?: Variant): Variant;
    function isTypeParameterDeclaration(opts?: Variant): Variant;
    function isTypeParameterInstantiation(opts?: Variant): Variant;
    function isTypeScript(opts?: Variant): Variant;
    function isTypeofTypeAnnotation(opts?: Variant): Variant;
    function isUnaryExpression(opts?: Variant): Variant;
    function isUnaryLike(opts?: Variant): Variant;
    function isUnionTypeAnnotation(opts?: Variant): Variant;
    function isUpdateExpression(opts?: Variant): Variant;
    function isUserWhitespacable(opts?: Variant): Variant;
    function isV8IntrinsicIdentifier(opts?: Variant): Variant;
    function isVariableDeclaration(opts?: Variant): Variant;
    function isVariableDeclarator(opts?: Variant): Variant;
    function isVariance(opts?: Variant): Variant;
    function isVoidPattern(opts?: Variant): Variant;
    function isVoidTypeAnnotation(opts?: Variant): Variant;
    function isWhile(opts?: Variant): Variant;
    function isWhileStatement(opts?: Variant): Variant;
    function isWithStatement(opts?: Variant): Variant;
    function isYieldExpression(opts?: Variant): Variant;
    function isBindingIdentifier(opts?: Variant): Variant;
    function isBlockScoped(opts?: Variant): Variant;
    function isExistentialTypeParam(opts?: Variant): Variant;
    function isForAwaitStatement(opts?: Variant): Variant;
    function isGenerated(opts?: Variant): Boolean;
    procedure isNumericLiteralTypeAnnotation(opts?: Variant);
    function isPure(opts?: Variant): Boolean;
    function isReferenced(opts?: Variant): Boolean;
    function isReferencedIdentifier(opts?: Variant): Variant;
    function isReferencedMemberExpression(opts?: Variant): Variant;
    function isScope(opts?: Variant): Variant;
    function isUser(opts?: Variant): Boolean;
    function isVar(opts?: Variant): Variant;
    function assertAccessor(opts?: Variant): Variant;
    function assertAnyTypeAnnotation(opts?: Variant): Variant;
    function assertArgumentPlaceholder(opts?: Variant): Variant;
    function assertArrayExpression(opts?: Variant): Variant;
    function assertArrayPattern(opts?: Variant): Variant;
    function assertArrayTypeAnnotation(opts?: Variant): Variant;
    function assertArrowFunctionExpression(opts?: Variant): Variant;
    function assertAssignmentExpression(opts?: Variant): Variant;
    function assertAssignmentPattern(opts?: Variant): Variant;
    function assertAwaitExpression(opts?: Variant): Variant;
    function assertBigIntLiteral(opts?: Variant): Variant;
    function assertBinary(opts?: Variant): Variant;
    function assertBinaryExpression(opts?: Variant): Variant;
    function assertBindExpression(opts?: Variant): Variant;
    function assertBlock(opts?: Variant): Variant;
    function assertBlockParent(opts?: Variant): Variant;
    function assertBlockStatement(opts?: Variant): Variant;
    function assertBooleanLiteral(opts?: Variant): Variant;
    function assertBooleanLiteralTypeAnnotation(opts?: Variant): Variant;
    function assertBooleanTypeAnnotation(opts?: Variant): Variant;
    function assertBreakStatement(opts?: Variant): Variant;
    function assertCallExpression(opts?: Variant): Variant;
    function assertCatchClause(opts?: Variant): Variant;
    function assertClass(opts?: Variant): Variant;
    function assertClassAccessorProperty(opts?: Variant): Variant;
    function assertClassBody(opts?: Variant): Variant;
    function assertClassDeclaration(opts?: Variant): Variant;
    function assertClassExpression(opts?: Variant): Variant;
    function assertClassImplements(opts?: Variant): Variant;
    function assertClassMethod(opts?: Variant): Variant;
    function assertClassPrivateMethod(opts?: Variant): Variant;
    function assertClassPrivateProperty(opts?: Variant): Variant;
    function assertClassProperty(opts?: Variant): Variant;
    function assertCompletionStatement(opts?: Variant): Variant;
    function assertConditional(opts?: Variant): Variant;
    function assertConditionalExpression(opts?: Variant): Variant;
    function assertContinueStatement(opts?: Variant): Variant;
    function assertDebuggerStatement(opts?: Variant): Variant;
    function assertDecimalLiteral(opts?: Variant): Variant;
    function assertDeclaration(opts?: Variant): Variant;
    function assertDeclareClass(opts?: Variant): Variant;
    function assertDeclareExportAllDeclaration(opts?: Variant): Variant;
    function assertDeclareExportDeclaration(opts?: Variant): Variant;
    function assertDeclareFunction(opts?: Variant): Variant;
    function assertDeclareInterface(opts?: Variant): Variant;
    function assertDeclareModule(opts?: Variant): Variant;
    function assertDeclareModuleExports(opts?: Variant): Variant;
    function assertDeclareOpaqueType(opts?: Variant): Variant;
    function assertDeclareTypeAlias(opts?: Variant): Variant;
    function assertDeclareVariable(opts?: Variant): Variant;
    function assertDeclaredPredicate(opts?: Variant): Variant;
    function assertDecorator(opts?: Variant): Variant;
    function assertDirective(opts?: Variant): Variant;
    function assertDirectiveLiteral(opts?: Variant): Variant;
    function assertDoExpression(opts?: Variant): Variant;
    function assertDoWhileStatement(opts?: Variant): Variant;
    function assertEmptyStatement(opts?: Variant): Variant;
    function assertEmptyTypeAnnotation(opts?: Variant): Variant;
    function assertEnumBody(opts?: Variant): Variant;
    function assertEnumBooleanBody(opts?: Variant): Variant;
    function assertEnumBooleanMember(opts?: Variant): Variant;
    function assertEnumDeclaration(opts?: Variant): Variant;
    function assertEnumDefaultedMember(opts?: Variant): Variant;
    function assertEnumMember(opts?: Variant): Variant;
    function assertEnumNumberBody(opts?: Variant): Variant;
    function assertEnumNumberMember(opts?: Variant): Variant;
    function assertEnumStringBody(opts?: Variant): Variant;
    function assertEnumStringMember(opts?: Variant): Variant;
    function assertEnumSymbolBody(opts?: Variant): Variant;
    function assertExistsTypeAnnotation(opts?: Variant): Variant;
    function assertExportAllDeclaration(opts?: Variant): Variant;
    function assertExportDeclaration(opts?: Variant): Variant;
    function assertExportDefaultDeclaration(opts?: Variant): Variant;
    function assertExportDefaultSpecifier(opts?: Variant): Variant;
    function assertExportNamedDeclaration(opts?: Variant): Variant;
    function assertExportNamespaceSpecifier(opts?: Variant): Variant;
    function assertExportSpecifier(opts?: Variant): Variant;
    function assertExpression(opts?: Variant): Variant;
    function assertExpressionStatement(opts?: Variant): Variant;
    function assertExpressionWrapper(opts?: Variant): Variant;
    function assertFile(opts?: Variant): Variant;
    function assertFlow(opts?: Variant): Variant;
    function assertFlowBaseAnnotation(opts?: Variant): Variant;
    function assertFlowDeclaration(opts?: Variant): Variant;
    function assertFlowPredicate(opts?: Variant): Variant;
    function assertFlowType(opts?: Variant): Variant;
    function assertFor(opts?: Variant): Variant;
    function assertForInStatement(opts?: Variant): Variant;
    function assertForOfStatement(opts?: Variant): Variant;
    function assertForStatement(opts?: Variant): Variant;
    function assertForXStatement(opts?: Variant): Variant;
    function assertFunction(opts?: Variant): Variant;
    function assertFunctionDeclaration(opts?: Variant): Variant;
    function assertFunctionExpression(opts?: Variant): Variant;
    function assertFunctionParameter(opts?: Variant): Variant;
    function assertFunctionParent(opts?: Variant): Variant;
    function assertFunctionTypeAnnotation(opts?: Variant): Variant;
    function assertFunctionTypeParam(opts?: Variant): Variant;
    function assertGenericTypeAnnotation(opts?: Variant): Variant;
    function assertIdentifier(opts?: Variant): Variant;
    function assertIfStatement(opts?: Variant): Variant;
    function assertImmutable(opts?: Variant): Variant;
    function assertImport(opts?: Variant): Variant;
    function assertImportAttribute(opts?: Variant): Variant;
    function assertImportDeclaration(opts?: Variant): Variant;
    function assertImportExpression(opts?: Variant): Variant;
    function assertImportDefaultSpecifier(opts?: Variant): Variant;
    function assertImportNamespaceSpecifier(opts?: Variant): Variant;
    function assertImportOrExportDeclaration(opts?: Variant): Variant;
    function assertImportSpecifier(opts?: Variant): Variant;
    function assertIndexedAccessType(opts?: Variant): Variant;
    function assertInferredPredicate(opts?: Variant): Variant;
    function assertInterfaceDeclaration(opts?: Variant): Variant;
    function assertInterfaceExtends(opts?: Variant): Variant;
    function assertInterfaceTypeAnnotation(opts?: Variant): Variant;
    function assertInterpreterDirective(opts?: Variant): Variant;
    function assertIntersectionTypeAnnotation(opts?: Variant): Variant;
    function assertJSX(opts?: Variant): Variant;
    function assertJSXAttribute(opts?: Variant): Variant;
    function assertJSXClosingElement(opts?: Variant): Variant;
    function assertJSXClosingFragment(opts?: Variant): Variant;
    function assertJSXElement(opts?: Variant): Variant;
    function assertJSXEmptyExpression(opts?: Variant): Variant;
    function assertJSXExpressionContainer(opts?: Variant): Variant;
    function assertJSXFragment(opts?: Variant): Variant;
    function assertJSXIdentifier(opts?: Variant): Variant;
    function assertJSXMemberExpression(opts?: Variant): Variant;
    function assertJSXNamespacedName(opts?: Variant): Variant;
    function assertJSXOpeningElement(opts?: Variant): Variant;
    function assertJSXOpeningFragment(opts?: Variant): Variant;
    function assertJSXSpreadAttribute(opts?: Variant): Variant;
    function assertJSXSpreadChild(opts?: Variant): Variant;
    function assertJSXText(opts?: Variant): Variant;
    function assertLVal(opts?: Variant): Variant;
    function assertLabeledStatement(opts?: Variant): Variant;
    function assertLiteral(opts?: Variant): Variant;
    function assertLogicalExpression(opts?: Variant): Variant;
    function assertLoop(opts?: Variant): Variant;
    function assertMemberExpression(opts?: Variant): Variant;
    function assertMetaProperty(opts?: Variant): Variant;
    function assertMethod(opts?: Variant): Variant;
    function assertMiscellaneous(opts?: Variant): Variant;
    function assertMixedTypeAnnotation(opts?: Variant): Variant;
    function assertModuleDeclaration(opts?: Variant): Variant;
    function assertModuleExpression(opts?: Variant): Variant;
    function assertModuleSpecifier(opts?: Variant): Variant;
    function assertNewExpression(opts?: Variant): Variant;
    function assertNoop(opts?: Variant): Variant;
    function assertNullLiteral(opts?: Variant): Variant;
    function assertNullLiteralTypeAnnotation(opts?: Variant): Variant;
    function assertNullableTypeAnnotation(opts?: Variant): Variant;
    function assertNumberLiteral(opts?: Variant): Variant;
    function assertNumberLiteralTypeAnnotation(opts?: Variant): Variant;
    function assertNumberTypeAnnotation(opts?: Variant): Variant;
    function assertNumericLiteral(opts?: Variant): Variant;
    function assertObjectExpression(opts?: Variant): Variant;
    function assertObjectMember(opts?: Variant): Variant;
    function assertObjectMethod(opts?: Variant): Variant;
    function assertObjectPattern(opts?: Variant): Variant;
    function assertObjectProperty(opts?: Variant): Variant;
    function assertObjectTypeAnnotation(opts?: Variant): Variant;
    function assertObjectTypeCallProperty(opts?: Variant): Variant;
    function assertObjectTypeIndexer(opts?: Variant): Variant;
    function assertObjectTypeInternalSlot(opts?: Variant): Variant;
    function assertObjectTypeProperty(opts?: Variant): Variant;
    function assertObjectTypeSpreadProperty(opts?: Variant): Variant;
    function assertOpaqueType(opts?: Variant): Variant;
    function assertOptionalCallExpression(opts?: Variant): Variant;
    function assertOptionalIndexedAccessType(opts?: Variant): Variant;
    function assertOptionalMemberExpression(opts?: Variant): Variant;
    function assertParenthesizedExpression(opts?: Variant): Variant;
    function assertPattern(opts?: Variant): Variant;
    function assertPatternLike(opts?: Variant): Variant;
    function assertPipelineBareFunction(opts?: Variant): Variant;
    function assertPipelinePrimaryTopicReference(opts?: Variant): Variant;
    function assertPipelineTopicExpression(opts?: Variant): Variant;
    function assertPlaceholder(opts?: Variant): Variant;
    function assertPrivate(opts?: Variant): Variant;
    function assertPrivateName(opts?: Variant): Variant;
    function assertProgram(opts?: Variant): Variant;
    function assertProperty(opts?: Variant): Variant;
    function assertPureish(opts?: Variant): Variant;
    function assertQualifiedTypeIdentifier(opts?: Variant): Variant;
    function assertRecordExpression(opts?: Variant): Variant;
    function assertRegExpLiteral(opts?: Variant): Variant;
    function assertRegexLiteral(opts?: Variant): Variant;
    function assertRestElement(opts?: Variant): Variant;
    function assertRestProperty(opts?: Variant): Variant;
    function assertReturnStatement(opts?: Variant): Variant;
    function assertScopable(opts?: Variant): Variant;
    function assertSequenceExpression(opts?: Variant): Variant;
    function assertSpreadElement(opts?: Variant): Variant;
    function assertSpreadProperty(opts?: Variant): Variant;
    function assertStandardized(opts?: Variant): Variant;
    function assertStatement(opts?: Variant): Variant;
    function assertStaticBlock(opts?: Variant): Variant;
    function assertStringLiteral(opts?: Variant): Variant;
    function assertStringLiteralTypeAnnotation(opts?: Variant): Variant;
    function assertStringTypeAnnotation(opts?: Variant): Variant;
    function assertSuper(opts?: Variant): Variant;
    function assertSwitchCase(opts?: Variant): Variant;
    function assertSwitchStatement(opts?: Variant): Variant;
    function assertSymbolTypeAnnotation(opts?: Variant): Variant;
    function assertTSAnyKeyword(opts?: Variant): Variant;
    function assertTSArrayType(opts?: Variant): Variant;
    function assertTSAsExpression(opts?: Variant): Variant;
    function assertTSBaseType(opts?: Variant): Variant;
    function assertTSBigIntKeyword(opts?: Variant): Variant;
    function assertTSBooleanKeyword(opts?: Variant): Variant;
    function assertTSCallSignatureDeclaration(opts?: Variant): Variant;
    function assertTSConditionalType(opts?: Variant): Variant;
    function assertTSConstructSignatureDeclaration(opts?: Variant): Variant;
    function assertTSConstructorType(opts?: Variant): Variant;
    function assertTSDeclareFunction(opts?: Variant): Variant;
    function assertTSDeclareMethod(opts?: Variant): Variant;
    function assertTSEntityName(opts?: Variant): Variant;
    function assertTSEnumBody(opts?: Variant): Variant;
    function assertTSEnumDeclaration(opts?: Variant): Variant;
    function assertTSEnumMember(opts?: Variant): Variant;
    function assertTSExportAssignment(opts?: Variant): Variant;
    function assertTSExpressionWithTypeArguments(opts?: Variant): Variant;
    function assertTSExternalModuleReference(opts?: Variant): Variant;
    function assertTSFunctionType(opts?: Variant): Variant;
    function assertTSImportEqualsDeclaration(opts?: Variant): Variant;
    function assertTSImportType(opts?: Variant): Variant;
    function assertTSIndexSignature(opts?: Variant): Variant;
    function assertTSIndexedAccessType(opts?: Variant): Variant;
    function assertTSInferType(opts?: Variant): Variant;
    function assertTSInstantiationExpression(opts?: Variant): Variant;
    function assertTSInterfaceBody(opts?: Variant): Variant;
    function assertTSInterfaceDeclaration(opts?: Variant): Variant;
    function assertTSIntersectionType(opts?: Variant): Variant;
    function assertTSIntrinsicKeyword(opts?: Variant): Variant;
    function assertTSLiteralType(opts?: Variant): Variant;
    function assertTSMappedType(opts?: Variant): Variant;
    function assertTSMethodSignature(opts?: Variant): Variant;
    function assertTSModuleBlock(opts?: Variant): Variant;
    function assertTSModuleDeclaration(opts?: Variant): Variant;
    function assertTSNamedTupleMember(opts?: Variant): Variant;
    function assertTSNamespaceExportDeclaration(opts?: Variant): Variant;
    function assertTSNeverKeyword(opts?: Variant): Variant;
    function assertTSNonNullExpression(opts?: Variant): Variant;
    function assertTSNullKeyword(opts?: Variant): Variant;
    function assertTSNumberKeyword(opts?: Variant): Variant;
    function assertTSObjectKeyword(opts?: Variant): Variant;
    function assertTSOptionalType(opts?: Variant): Variant;
    function assertTSParameterProperty(opts?: Variant): Variant;
    function assertTSParenthesizedType(opts?: Variant): Variant;
    function assertTSPropertySignature(opts?: Variant): Variant;
    function assertTSQualifiedName(opts?: Variant): Variant;
    function assertTSRestType(opts?: Variant): Variant;
    function assertTSSatisfiesExpression(opts?: Variant): Variant;
    function assertTSStringKeyword(opts?: Variant): Variant;
    function assertTSSymbolKeyword(opts?: Variant): Variant;
    function assertTSTemplateLiteralType(opts?: Variant): Variant;
    function assertTSThisType(opts?: Variant): Variant;
    function assertTSTupleType(opts?: Variant): Variant;
    function assertTSType(opts?: Variant): Variant;
    function assertTSTypeAliasDeclaration(opts?: Variant): Variant;
    function assertTSTypeAnnotation(opts?: Variant): Variant;
    function assertTSTypeAssertion(opts?: Variant): Variant;
    function assertTSTypeElement(opts?: Variant): Variant;
    function assertTSTypeLiteral(opts?: Variant): Variant;
    function assertTSTypeOperator(opts?: Variant): Variant;
    function assertTSTypeParameter(opts?: Variant): Variant;
    function assertTSTypeParameterDeclaration(opts?: Variant): Variant;
    function assertTSTypeParameterInstantiation(opts?: Variant): Variant;
    function assertTSTypePredicate(opts?: Variant): Variant;
    function assertTSTypeQuery(opts?: Variant): Variant;
    function assertTSTypeReference(opts?: Variant): Variant;
    function assertTSUndefinedKeyword(opts?: Variant): Variant;
    function assertTSUnionType(opts?: Variant): Variant;
    function assertTSUnknownKeyword(opts?: Variant): Variant;
    function assertTSVoidKeyword(opts?: Variant): Variant;
    function assertTaggedTemplateExpression(opts?: Variant): Variant;
    function assertTemplateElement(opts?: Variant): Variant;
    function assertTemplateLiteral(opts?: Variant): Variant;
    function assertTerminatorless(opts?: Variant): Variant;
    function assertThisExpression(opts?: Variant): Variant;
    function assertThisTypeAnnotation(opts?: Variant): Variant;
    function assertThrowStatement(opts?: Variant): Variant;
    function assertTopicReference(opts?: Variant): Variant;
    function assertTryStatement(opts?: Variant): Variant;
    function assertTupleExpression(opts?: Variant): Variant;
    function assertTupleTypeAnnotation(opts?: Variant): Variant;
    function assertTypeAlias(opts?: Variant): Variant;
    function assertTypeAnnotation(opts?: Variant): Variant;
    function assertTypeCastExpression(opts?: Variant): Variant;
    function assertTypeParameter(opts?: Variant): Variant;
    function assertTypeParameterDeclaration(opts?: Variant): Variant;
    function assertTypeParameterInstantiation(opts?: Variant): Variant;
    function assertTypeScript(opts?: Variant): Variant;
    function assertTypeofTypeAnnotation(opts?: Variant): Variant;
    function assertUnaryExpression(opts?: Variant): Variant;
    function assertUnaryLike(opts?: Variant): Variant;
    function assertUnionTypeAnnotation(opts?: Variant): Variant;
    function assertUpdateExpression(opts?: Variant): Variant;
    function assertUserWhitespacable(opts?: Variant): Variant;
    function assertV8IntrinsicIdentifier(opts?: Variant): Variant;
    function assertVariableDeclaration(opts?: Variant): Variant;
    function assertVariableDeclarator(opts?: Variant): Variant;
    function assertVariance(opts?: Variant): Variant;
    function assertVoidPattern(opts?: Variant): Variant;
    function assertVoidTypeAnnotation(opts?: Variant): Variant;
    function assertWhile(opts?: Variant): Variant;
    function assertWhileStatement(opts?: Variant): Variant;
    function assertWithStatement(opts?: Variant): Variant;
    function assertYieldExpression(opts?: Variant): Variant;
  end;

  HubInterface = interface
    function getCode: String;
    function getScope: Scope;
    function addHelper(name: String): Variant;
    function buildError(node: Node; msg: String; Error: ErrorConstructor): Error;
  end;

  Hub = class(HubInterface) external
    procedure Create;
    function getCode: String;
    function getScope: Scope;
    function addHelper(name: String): Variant;
    function buildError(node: Node; msg: String; Error?: ErrorConstructor): Error;
  end;

  TraversalContext = interface
    property parentPath: NodePath;
    property scope: Scope;
    property state: S;
    property opts: TraverseOptions;
  end;

  ImplGetOfArray = Variant;

  ImplGetByKey = Variant;

  ImplGetRecursive = Variant;

  NodePathResult = Variant;

  VirtualTypeAliases = interface
    property BindingIdentifier: t.Identifier;
    property BlockScoped: Node;
    property ExistentialTypeParam: t.ExistsTypeAnnotation;
    property Flow: Variant;
    property ForAwaitStatement: t.ForOfStatement;
    property Generated: Node;
    property NumericLiteralTypeAnnotation: t.NumberLiteralTypeAnnotation;
    property Pure: Node;
    property Referenced: Node;
    property ReferencedIdentifier: Variant;
    property ReferencedMemberExpression: t.MemberExpression;
    property RestProperty: t.RestElement;
    property Scope: Variant;
    property SpreadProperty: t.RestElement;
    property User: Node;
    property Var: t.VariableDeclaration;
  end;

implementation



end.
